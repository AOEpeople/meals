<?phpdeclare(strict_types=1);namespace App\Mealz\MealBundle\Event\Subscriber;use App\Mealz\MealBundle\Entity\Meal;use App\Mealz\MealBundle\Entity\MealCollection;use App\Mealz\MealBundle\Event\ParticipationUpdateEvent;use App\Mealz\MealBundle\Service\ParticipationCountService;use App\Mealz\MealBundle\Service\Publisher\PublisherInterface;use Psr\Log\LoggerInterface;use App\Mealz\MealBundle\Service\Publisher\Publisher;use Symfony\Component\EventDispatcher\EventSubscriberInterface;class ParticipationSubscriber implements EventSubscriberInterface{    private LoggerInterface $logger;    private PublisherInterface $publisher;    public function __construct(LoggerInterface $logger, PublisherInterface $publisher)    {        $this->logger = $logger;        $this->publisher = $publisher;    }    public static function getSubscribedEvents(): array    {        return [            ParticipationUpdateEvent::class => 'onUpdate',        ];    }    public function onUpdate(ParticipationUpdateEvent $event): void    {        $mealDay = $event->getParticipant()->getMeal()->getDay();        $participation = ParticipationCountService::getParticipationByDay($mealDay);        $dayMeals = $mealDay->getMeals();        $mealsAvailability = $this->getMealsAvailability($dayMeals, $participation['totalCountByDishSlugs']);        $data = $this->getParticipationStatus($dayMeals, $mealsAvailability, $participation['countByMealIds']);        $this->publish($data);    }    private function getParticipationStatus(MealCollection $meals, array $availability, array $bookingCount): array    {        $status = [];        foreach ($meals as $meal) {            $mealId = $meal->getId();            $dishSlug = $meal->getDish()->getSlug();            $mealAvailability = $availability[$mealId] ?? false;            $mealStatus = [                'count' => $bookingCount[$mealId][$dishSlug]['count'] ?? 0,  // TODO: count for combined meal ?????                'available' => false            ];            if (is_array($mealAvailability) && $mealAvailability['available']) {                $mealStatus['available'] = true;                $mealStatus['availableWith'] = $mealAvailability['availableWith'];            } else {                $mealStatus['available'] = $mealAvailability;            }            $status[$mealId] = $mealStatus;        }        return $status;    }    /**     * @return array<int, bool|array{available: bool, availableWith: list<int>}> Key-value pair of meal-ID and corresponding availability     */    private function getMealsAvailability(MealCollection $meals, array $bookingStatus): array    {        $availability = [];        foreach ($meals as $meal) {            $mealId = $meal->getId();            if ($meal->isCombinedMeal()) {                $simpleMeals = array_filter($meals->toArray(), static fn (Meal $meal) => !$meal->isCombinedMeal());                $availability[$mealId] = $this->getCombinedMealAvailability($simpleMeals, $bookingStatus);            } else {                $bookingCount = $this->getMealBookingCount($meal, $bookingStatus);                $availability[$mealId] = (null !== $bookingCount) && $this->isMealAvailable($meal, $bookingCount);            }        }        return $availability;    }    /**     * @param Meal[] $meals Array of simple meals     */    private function getCombinedMealAvailability(array $meals, array $bookingStatus)    {        $dishes = $this->getCombinedMealAvailableDishes($meals, $bookingStatus);        $dishCount = count($dishes);        // dish count equals simple meal count, i.e. all dishes all available; unrestricted availability        if ($dishCount === count($meals)) {            return true;        }        // dish count is greater than zero, but less than simple meal count; restricted availability        if (($dishCount > 0) && ($dishCount < count($meals))) {            return [                'available' => true,                'availableWith' => $dishes            ];        }        // no availability        return false;    }    /**     * @param Meal[] $meals Array of simple meals     *     * @psalm-return list<int> Dish-IDs     */    private function getCombinedMealAvailableDishes(array $meals, array $bookingStatus): array    {        $dishes = [];        $dishAvailability = $this->getCombinedMealDishAvailability($meals, $bookingStatus);        foreach ($dishAvailability as $dishId => $availability) {            if ($availability === false) {                return [];            }            if ($availability === true) {                $dishes[] = [$dishId];            } elseif (is_array($availability)) {  // $availability contains availability of dish variations                $availableItems = array_filter($availability);  // filter out available variations                if (0 === count($availableItems)) {                    return [];                }                $dishes[] = array_keys($availableItems);            }        }        return 0 < count($dishes) ? array_merge(...$dishes) : [];    }    /**     * Checks, given a set of meals and their booking status, if a combined meal can be booked.     *     * @param Meal[] $meals Array of simple meals     */    private function getCombinedMealDishAvailability(array $meals, array $bookingStatus): array    {        $availability = [];        foreach ($meals as $meal) {            $dish = $meal->getDish();            $parentDish = $dish->getParent();            $mealBookingCount = $this->getMealBookingCount($meal, $bookingStatus);            $dishAvailability = (null !== $mealBookingCount) && $this->isMealAvailable($meal, $mealBookingCount, 0.5);            if (null !== $parentDish) {                $availability[$parentDish->getId()][$dish->getId()] = $dishAvailability;            } else {                $availability[$dish->getId()] = $dishAvailability;            }        }        return $availability;    }    private function getMealBookingCount(Meal $meal, array $bookingStatus): ?float    {        $dishSlug = $meal->getDish()->getSlug();        if (!isset($bookingStatus[$dishSlug]['count']) || !is_float($bookingStatus[$dishSlug]['count'])) {            $bookingCount = null;        } else {            $bookingCount = $bookingStatus[$dishSlug]['count'];        }        return $bookingCount;    }    /**     * Checks if a given meal is available for booking as simple or combined meal.     *     * @param float $factor Calculation factor. It's 1.0 for simple meal and 0.5 for combined meal.     */    private function isMealAvailable(Meal $meal, float $bookingCount, float $factor = 1.0): bool    {        $participationLimit = $meal->getParticipationLimit();        if (0 === $participationLimit) {            return true;        }        return ($bookingCount + $factor) <= (float) $participationLimit;    }    private function publish(array $data): void    {        $published = $this->publisher->publish(Publisher::TOPIC_PARTICIPATION_UPDATES, $data);        if (!$published) {            $this->logger->error('publish failure', ['topic' => Publisher::TOPIC_PARTICIPATION_UPDATES]);        }    }}